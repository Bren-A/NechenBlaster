2. EDIT::: I fixed the issue, it now passes the sanity check without any problems. The projectile fires without giving an error. Turns out the projectiles were off by a pixel where they were meant to be shot. 
Previous: While testing the game, the game seemed perfectly fine and everything however when doing the sanity test it kept failing. The test stops at my implementation of how the player fires a cabbage. Although it works in the game, it seems that the cabbage isn't created when the space bar is pressed. Judging from the example game, my game works similar. I'm not sure why the sanity tests don't see the cabbage as created where the NachenBlaster is made.

3. Since the spec didn't specify whether torpedoes carry over to the next round, my game just resets the amount of torpedoes to 0. Another assumption I made concerned how the damage worked. Since it said that the enemy can get damaged when touching the projectile or when the projectile touches the enemy, I just made it so that only the projectile attacks the ship and not vise versa since it'd do the same thing essentially. I was confused on printing the game text, so I also assumed that for the game text that it wanted two spaces before the next stat, and I just added two space characters right before the text.

StudentWorld class:
// Returns the beginning of the list
std::list<Actor*>::iterator getBegin();
// Returns the end of the list
std::list<Actor*>::iterator getEnd();
If Actor objects need to go through the list of current gameobjects(e.g. take it can access the list that holds them all

// Adds Actors to the list
void addObjects(Actor* a);
This function allows Actors to access the list and add new Actor objects(e.g. Add projectiles)

// Returns pointer to NachenBlaster
NachenBlaster* getShip();
Accesses the ship pointer so that other Actors can call its functions to modify it(e.g. take damage)

----------------------------------------------------------------------------------------------------------------
Actor class:

When I built the actor class I tested it by making fake functions so that it won't be purely virtual. I mainly checked if the dies and isDead function works properly.

virtual bool isEnemy() const ; 
virtual bool isGoodie() const;
virtual bool isPlayer() const;

These three functions do essentially the same thing, which is it returns True if the item is in one of those categories, or false if not. Since all the functions were put together into one list I needed a way to check if the Actor was a player, enemy, goodie, or none of the above. I made these virtual since Actors can differ in these characteristics. However, I didn't make them fully virtual since that would require more code. Instead, I made a general case where each function by default returned false, and for each category there was a funtion that overloaded it. In derived classes Goodie, NachenBlaster, and Enemy, isGoodie(), isPlayer(), and isEnemy() were overridden to be true respectively. Instead of having all the derived classes have their own function, only the ones that needed to return true were added. 

virtual void doSomething() = 0;

doSomething() is a pure virtual function since all the Actors had a unique action it had to do during a tick, so there was no general action that doSomething() could do. And since all Actors had to do something during a tick, I added the function into the base class.

void dies();
bool isDead() const;
Each item has a bool that keeps track of whether it had "died" or not. in this case dead entails that the item has gone off screen, interacted with other Actors on the screen, or actually have died. All Actors are created and start as alive until something happens(e.g. one of the instances listed above). dies() changees the state to dead when one of the cases that cause the object to be needed to be deleted occurs, and isDead() checks to see if it has died or not, so that the program knows whether it should delete the object and/or play sounds, update a status, etc. Since there is no special case; you can only be dead or not dead, these functions are not virtual.

virtual int getID() const = 0; 
I implemented this function thinking I'd use it to check what kind of Actor it is, but I ended up using the functions isEnemy(), isGoodie() and isPlayer() since they are more general, making the if statements easier to implement. This function is purely virtual since each Actor has its own sprite ID.


virtual void damage(int n);
I used this function to add/subtract health from items. I had trouble making the enemies and the Nachenblaster in the same base class, so what I did instead was similar to the isEnemy(), isGoodie(), and isPlayer() functions. For the base function the damage class does nothing since most of the items can't have health deducted from them and just returns, while in the derived Enemy and NachenBlaster classes I have the damage function decrement health from them

bool isKilled() const;
void kill();
These two functions act similar to isDead() and dies() respectively. Even if an Actor dies, it can die either by going off screen, getting picked up, or getting killed. This keeps track of whether an Actor has "died" by going offscreen or if it was killed. Simlar to the functions mentioned, there can only be it was killed or it wasn't, without any special cases. Therefore, the function is not virtual.

bool isTouching(Actor& b) const;
This function is used to run through the list of all the Actors and check if the current Actor is touching another Actor in the list or not. Since this function uses every item and not specific ones, there are no derived versions of it and it is not virtual.

void setWorld(StudentWorld* world);
All of the Actors have a pointer to the world they are currently in so that they can interact with other Actors in the world. There are no special ways each Actor handles pointers, so it is not virtual

-------------------------------------------------------------------------------
NachenBlaster class:

I tested this class by first checking if it will show up on the screen or not. Then I tested whether or not the projectiles worked. I set the torpedoes to a number besides zero and checked to see if it worked properly. I also did the same with the cabbage. Once I implemented Aliens, I used a still alien with health 16 to test if the amount of damage done is correct. If it took 2 shots with the torpedo and 8 shots with the cabbage, then I knew that the projectiles worked properly. I also used the setGameStatText() function to make sure that the getHealth() and damage() function worked properly. I set space to damage the ship by 5, and if the health went down by 10% then the damage function was implemented correctly. I also made sure that when adding health the health never went past 100%.

void doSomething();
The NachenBlaster receives player input unlike other classes, so it has its own special function to do so

bool isPlayer() const;
The default virtual constructor in Actor returns false, but since this is the player it is overridden to return true

int getID() const;
The NachenBlaster has its own unique ID, so it has its own getID function

int getHealth() const;
Since getHealth() accesses a private data member of NachenBlaster, it is not virtual

int cabbPower() const;
The NachenBlaster is the only one that can fire cabbages, and since there are no derived classes, cabbPower() is not virtual

int nTorps() const;
void changeTorps(bool inc);
nTorps() keeps track of the number of torpedoes a NachenBlaster has while changeTorps() can modify this number. The NachenBlaster is the only class that can store torpedoes and add/remove them from their inventory, so there is no function for this in the base class nor is it virtual.

void damage(int n);
The NachenBlaster can gain and lose health, so it has its own version of the virtual function from the Actor class.

void flush();
NachenBlaster is the only class with the ability to regain health, and flush is meant to prevent the health from going over the max limit. Therefore it is not virtual and is only defined in the NachenBlaster class.

-------------------------------------------------------------------------------
Enemy class:

I tested this class along with the enemy derived classes since some of these functions are virtual and doesn't have a doSomething function. I made sure that the fireTurnip worked properly by setting the space bar to fire a turnip at the NachenBlaster and checking to see if the damage dealt was correct. I also tested to make sure the getDir and setSpeed, changePlan functions worked properly and would change the speed and direction accordingly.

bool isEnemy() const;
Since the the base isEnemy() function returns false, it needs to have a different function that returns true

void setHealth(int h);
Each Enemy has varying health depending on the level, but since the way to add health is the same regardless of what kind of enemy it is, the function is not virtual.

int getHealth() const;
Each Enemy has health and since getting health is the same for every enemy, the function to get health is in the Enemy class instead of in any of the derived classes.

void setSpeed(double s);
Each enemy can have differing speeds, but setting the speed is the same regardless of the enemy, therefore setSpeed() is not virtual and is implemented in the Enemy class instead of in its derived classes.

double getSpeed() const;
All Enemies have a speed data member, and since the derived functions don't it isn't virtual

void changePlan(int p);
int getPlan() const;
The enemies all move in different directions based on the plan of its course, and these functions get the plan and set the plan every tick. And since the Enemies set the duration of each flight plan similarly, it is not virtual and is implemented in the Enemy class

virtual void dropGoodie();
By default, enemies don't drop goodies, but since enemies like the Smoregon and Snagglegon do, the function is virtual so that each of these enemies has its own implementation on how to drop a goodie.Enemies have different goodies they drop.

int getDir() const;
void changeDir(int d);
Enemies do not fly in a straight line, instead they move straight and diagonally. All Enemies move in the same directions and hold the same variable to keep track of what direction they're moving, so this function does not need to be virtual.

virtual bool hitsShip();
This function checks to see if the enemy has run into the player ship. All the enemies can crash into the NachenBlaster. However, what happens when it runs into a ship varies depending on the type of enemy. While Smallgons and Smoregons do the same thing, Snagglegons don't hence why it is not a pruely virtual function but rather only a virtual one.

void damage(int n);
All the ships can get hurt and take damage in the same way, so there are no special functions for it.

virtual bool remove();
remove() determines what to do if an enemy dies. Smallgons and Smoregons do the same thing when they die however Snagglegons do someting else, which is why it is virtual instead of purely virtual.

void moveShip();
Enemy ships move the same way, therefore it is not virtual

virtual void checkPlan();
While enemies move the same way and in the same directions, each has a different pattern. Since each moves differently, checkPlan is a virtual function.

void fireTurnip();
Only enemies fire Turnips, and they all fire it the same way, so it is not virtual.

virtual bool attack();
Determines the odds that an Enemy will attack. The odds differ depending on the type of enemy, so it is virtual.

---------------------------------------------------------------------------------
Smallgon class:

I tested the enemies in similar ways. First, I checked to make sure that the proper enemy showed up and if they attacked properly. I didn't make them move and checked if the attack odds and if colliding with it did what was expected. I then tested to see if the Smallgon moved and changed direction similar to in the example game. I also then checked that the scores and the proper sound effects were implemented when the enemy dies.

void doSomething();
Each Smallgon has a unique action every tick.

int getID() const;
Each Smallgon has a unique sprite ID compared to other enemies

-------------------------------------------------------------------------------
Smoregon class:

In addition to the things I tested in the Smallgon class, I tested to see if they dropped items properly. I's shoot at an immobile Smoregon and see how often it'd drop goodies, and if the goodies were the repair and torpedo goodies. I also then tested its other attack function, the ram function and checked if the speed increased and if it kept going straight left without changing course.

void doSomething();
Each Smoregon has a unique action every tick

int getID() const;
Each Smoregon has a unique sprite ID compared to other enemies

void dropGoodie();
Smoregons have a change of dropping items, which a regular enemy does not

-------------------------------------------------------------------------------
Snagglegon class:

Unlike the other two, the Snagglegon doesn't have a changing pattern of movement, so I tested to make sure that the Snagglegon would move diagonally up and down the screen. I also did something similar as the Smoregon to test the goodies, however I checked if the Life goodie would drop and if it was less often then the drops of the Smoregon. I also checked to make sure the Torpedo functioned properly and would shoot and do the proper amount of damage. Since the actions for when the Snagglegon dies is a bit different from the two others, I also checked that the score incremented properly and the amount of damage taken when the NachenBlaster runs into it is different as well

int getID() const;
Snagglegons have a unique sprite ID compared to other enemeies

void doSomething();
Snagglegons have a unique action every tick

void checkPlan();
Unlike regular enemies, Snagglegons have a different movement path

bool attack();
The odds of a Snagglegon attacking and the types of attacks a Snagglegon do are distince from a regular Enemy

void dropGoodie();
A Snagglegon drops different goodies from a normal enemy and with different odds.

bool remove();
What happens when a Snagglegon dies is different from what happens with regular enemies

bool hitsShip();
When a snagglegon runs into the NachenBlaster it takes more damage then a regulat enemy, so it nees its own function for when it hits a ship.

-------------------------------------------------------------------------------
Projectile class:

I checked the function by leaving the projectiles floating in the air and checked if the projectiles did the proper amount of damage when touching. I also checked to make sure they disappeared when the ship moves over it. 

void checkDamage(int n, bool enemy);
Every projectile checks for if it hits a ship and checks the damage. The way projectiles deal damage is the same regardless of the type

-------------------------------------------------------------------------------
Cabbage class:

I tested to make sure that the projectile works properly by first just creating the projectile in the middle of the screen and checking if it moved properly. I then checked if the projectile would disappear when running into a static enemy.  

int getID() const;
Cabbages have a unique Sprite ID

void doSomething();
Cabbages are a player projectile and act differently from the enemy projectiles

-------------------------------------------------------------------------------
Turnip class:

I did something similar to the Cabbage class, however instead of having the Turnip attack a standstill enemy, I made it attack the NachenBlaster. I also made sure to see that the amount of damage was correct and that the turnip disappears when it hits the NachenBlaster. 
int getID() const;
Turnnips have a unique sprite ID

void doSomething();
Turnips are an enemy projectile and behave more specially than a regular projectile

-------------------------------------------------------------------------------
Fartpedo class:

Since both enemies and the Player can use Torpedoes, I combined the tests for the cabbage class and turnip class into one for this one. I first tested if it'd work properly against enemies and the player. I then tested to make sure that it will work when actually shot by the enemy or the player.

int getID() const;
Flatulent Torpedoes have a specific sprite ID.

void doSomething();
Flatulent Torpedoes can be used by either enemies or the NachenBlaster and they have different properties from the other two, so how it acts each tick is different from am regular projectile.

-------------------------------------------------------------------------------
Goodie class:

I tested the getGoodie function by randomly placing goodies that stay on the map and have the player walk over it, and having it output that it got a goodie when it touches it. I also tested to make sure that only the player can touch it by making the enemy move over a goodie and checking that it wouldn't disappear when the enemy ran over it. I also made sure that when picking up a goodie the score will increase accordingly. I then implemented them into the enemy classes to make sure that they drop from enemies and can be properly picked up.

bool isGoodie() const;
By default isGoodie() returns false. So Goodie has its own function that returns true instead since it is a goodie.

bool getGoodie();
Goodies have to get checked if they are picked up or not regardless of what they do, which is why getGoodie() isn't in any derived classes of Goodie.

-------------------------------------------------------------------------------
Torpedo class:

I checked to make sure that the goodie could get picked up and then check that it incremented the number of torpedoes by the proper amount. I then check if the player can fire the given torpedoes. After implementing it to move, I checked that it would die when going off screen and it can still be picked up only once. In the beginning my goodies were able to be picked up more than once before they died.

int getID() const;
Torpedoes have a specific sprite ID.

void doSomething();
Torpedoes augment the player in a unique way to other goodies
-------------------------------------------------------------------------------
Life class:

Similar to the Torpedo class, but I checked to make sure that the amount of lives would increase instead of the number of torpedoes.

int getID() const;
Life has a specific sprite ID.

void doSomething();
Life augments the player in a unique way to other goodies

-------------------------------------------------------------------------------
Repair class:

I added a button to the NachenBlaster class that would decrement the health of the ship when touched and another that would spawn a repair goodie. I then would inflict damage on the ship and check to make sure it incremented the health properly. I then also checked to see what happens when a goodie is picked up despite health being full. I checked to make sure it would always only stop at 100% and wouldn't increase beyond that point.

int getID() const;
Repair goodies have a specific sprite ID.

void doSomething();
Repair augments the player in a unique way to other goodies

-------------------------------------------------------------------------------
Explosion class:

I first checked to see if it worked standalone and if the explosion sound would go off and show the animation. After I added it to still enemies and checked that it exploded in the right place in that case. Then I checked if it also worked on moving objects.

int getID() const;
Explosions have a specific sprite ID.

void doSomething();
Explosions are only used when enemies die and are more simple than other Acotrs

-------------------------------------------------------------------------------
Star class:

Since star doesn't interact with other objects, I just had to make sure that the star moves left one pixel and the sizes would vary. I also checked to make sure that the stars would die after going offscreen and that the screen would be occupied by new stars again in the given odds.

int getID() const;
Stars have a specific sprite ID.

void doSomething();
Stars are passive backgroud objects. They don't need to interact with other players or objects.
